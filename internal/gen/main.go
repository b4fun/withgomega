package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"net/http"
	"os"
	"strings"
)

func main() {
	writer := WithGomegaWriter{
		PackageName:        "withgomega",
		Source:             "https://raw.githubusercontent.com/onsi/gomega/v1.9.0/matchers.go",
		GomegaImportPath:   "github.com/onsi/gomega",
		WithGomegaTypeName: "Matcher",
	}

	flag.StringVar(&writer.PackageName, "package", writer.PackageName, "package name")
	flag.StringVar(&writer.Source, "source", writer.Source, "source URL")
	flag.StringVar(&writer.GomegaImportPath, "gomega", writer.GomegaImportPath, "gomega import path")
	flag.StringVar(&writer.WithGomegaTypeName, "withgomega-type", writer.WithGomegaTypeName, "withgomega type name")
	flag.Parse()

	parser, err := NewGomegaParserFromRemote(writer.Source)
	if err != nil {
		panic(err)
	}

	writer.Write(os.Stdout, parser.ParseMatcherFunctions())
}

type MatcherFunction struct {
	Name       string
	Params     string
	ParamNames []string
	Results    string
	Comment    string
}

type WithGomegaWriter struct {
	PackageName        string
	Source             string
	GomegaImportPath   string
	WithGomegaTypeName string
}

func (enc WithGomegaWriter) writeHeader(w io.Writer) error {
	_, err := fmt.Fprintf(
		w,
		`// Package %s generated by withgomega/gen. DO NOT EDIT.
// source: %s
package %s

import (
	"time"

	. "%s"
	"%s/types"
)`+"\n\n",
		enc.PackageName, enc.Source, enc.PackageName,
		enc.GomegaImportPath, enc.GomegaImportPath,
	)
	if err != nil {
		return err
	}

	return nil
}

func (enc WithGomegaWriter) writeStruct(w io.Writer) error {
	_, err := fmt.Fprintf(
		w,
		`type %s struct {}`+"\n\n",
		enc.WithGomegaTypeName,
	)
	if err != nil {
		return err
	}

	return nil
}

func (enc WithGomegaWriter) Write(
	w io.Writer,
	matcherFunctions []MatcherFunction,
) error {
	if err := enc.writeHeader(w); err != nil {
		return err
	}

	if err := enc.writeStruct(w); err != nil {
		return err
	}

	for _, f := range matcherFunctions {
		_, err := fmt.Fprintf(
			w,
			`
%s
func (%s) %s%s %s {
	return %s(%s)
}`+"\n",
			f.Comment, enc.WithGomegaTypeName,
			f.Name, f.Params, f.Results,
			f.Name, strings.Join(f.ParamNames, ", "),
		)
		if err != nil {
			return err
		}
	}

	return nil
}

type GomegaParser struct {
	Content string
	File    *ast.File
}

func NewGomegaParserFromContent(content string) (*GomegaParser, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", content, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	rv := &GomegaParser{
		Content: content,
		File:    file,
	}

	return rv, nil
}

func NewGomegaParserFromRemote(url string) (*GomegaParser, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("get %s: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("get %s: %s", url, resp.Status)
	}

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read %s: %w", url, err)
	}

	return NewGomegaParserFromContent(string(b))
}

func (p *GomegaParser) getString(x ast.Node) string {
	return strings.TrimSpace(p.Content[x.Pos()-1 : x.End()])
}

func (p *GomegaParser) isMatcherFunction(f *ast.FuncDecl) bool {
	if !f.Name.IsExported() {
		return false
	}
	if len(f.Type.Results.List) != 1 {
		return false
	}
	returnType := p.getString(f.Type.Results.List[0].Type)
	return returnType == "types.GomegaMatcher"
}

func (p *GomegaParser) ParseMatcherFunctions() []MatcherFunction {
	var rv []MatcherFunction
	for _, ff := range p.File.Decls {
		funcDecl, ok := ff.(*ast.FuncDecl)
		if !ok {
			continue
		}

		if !p.isMatcherFunction(funcDecl) {
			continue
		}

		mf := MatcherFunction{
			Name:    funcDecl.Name.Name,
			Params:  p.getString(funcDecl.Type.Params),
			Results: p.getString(funcDecl.Type.Results),
			Comment: p.getString(funcDecl.Doc),
		}
		for _, param := range funcDecl.Type.Params.List {
			paramName := param.Names[0].Name
			if strings.HasPrefix(p.getString(param.Type), "...") {
				paramName += "..."
			}
			mf.ParamNames = append(mf.ParamNames, paramName)
		}
		rv = append(rv, mf)
	}

	return rv
}
